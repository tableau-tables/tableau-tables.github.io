{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tableau: Extended Table Creation I write books and courses, and I need to be able to create tables that are just a bit fancier than regular Markdown can generate. How place values work in binary Bit position 7 6 5 4 3 2 1 0 Bits 1 0 0 1 0 0 1 1 Place value \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 Bit x value 128 0 0 16 0 0 2 1 So, I wrote a kind of universal Markdown extension, called Tableau Table . Features include: Headerless tables Multiline headers Multiple separate headers Headers in columns Row and column span Per cell alignment and CSS classes Default attributes, both down columns and across rows Table-wide classes Caption Continuation lines Compatible (with two exceptions) with standard markdown tables And, because I like to experiment with different layouts and formatting, the tables generated by tableau table are styled using CSS classes, not inline attributes. If You Want to Use Tableau Tables You'll need to find an extension/plugin for the particular Markdown processor you're using. Marked (JavaScript) Extension available on NPM. See https://www.npmjs.com/package/tableau-markd . Markdown-It (JavaScript) Extension available on NPM. See https://www.npmjs.com/package/tableau-markdown-it . Python Markdown The extension is available through GitHub. For information see https://github.com/tableau-tables/python-tableau-parser . If you use a different Markdown Processor I use multiple Markdown processors, and I didn't want to have to implement a whole new tableau plugin for each. Instead, I wrote two library implementations of tableau, one in Python and the other in JavaScript. These libraries are intended to make it easy to write a plugin so that you can use tableau-formatted tables in a Markdown processor that doesn't currently support it. I wrote the Marked extension in a couple of hours (most of which was spent fighting with Typescript types). If you're interested in writing an extension, see the guide . If your particular environment requires features not currently in the library, let me know and I'll add them. If you'd like to create a version of the libraries for another programming language, please let me know so we can coordinate effort. Basic Markup Tableau is compatible with existing Markdown table conventions providing every row in the markup starts and ends with a pipe character: | Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | |:--------|:-------------|-------------:|--------------:|-----------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Columns are separated using pipe characters (\"|\"), and the second line both separates the headings from the table body and also gives the alignment of each of the columns. Formatted, it looks like this: Country Region Minimum Nos. Probably Nos. Speculative Nos. India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 Multiple Header Lines Output Markdown source Country Region Minimum Probable Speculative Numbers Numbers Numbers India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 | Country | Region | Minimum | Probable | Speculative | | | | Numbers | Numbers | Numbers | |:--------|:-------------|---------:|---------:|-------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Every line before the format line is considered a header. No Header Lines Output Markdown source India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 |:--------|:-------------|---------:|---------:|-------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | No Format Line Output Markdown source India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Spanned Rows Output Markdown source Country Region Minimum Probable Speculative Numbers Numbers Numbers India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 | Country | Region | Minimum | Probable | Speculative | |^ |^ | Numbers | Numbers | Numbers | |:--------|:-------------|---------:|---------:|-------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | An up-arrow (^) immediately after the pipe in any cell causes it to merge with the cell above. Multiple consecutive cells can be merged. Tableau Format Specifications In the preceding table, the two cells at the start of the second row are merged with the cells above. This is done using the up-arrow format specification. Every cell in a tableau table can have one or more format specifications. They must immediately follow the cell's opening pipe, with no intervening spaces. The valid format specifications are: ^ Merge this cell with the one above it. Multiple cells in a column may be merged { Merge this cell with the one to its left. Multiple cells in a row may be merged < Left align this cell = Center this cell > Right align this cell # Make this cell a header (use <th> ) .class Apply the CSS class to this cell The two span specifications ( ^ and { ) must appear alone (as the cell formatting is taken from the cell above or to the left). Otherwise, a format specification can contain an optional alignment specifier, an optional heading specifier, and zero or more class specifiers. These three types of specifier can appear in any order: |<#.warn.big Note |.info> Meaning | The first cell is a left-aligned heading cell with the CSS classes warn and big , while the second is a right-aligned cell with the class info . Propagating Formats Along a Row Any format specification can be followed by an ellipsis (either three periods ... or a Unicode ellipsis, \u2026 ). This format will then be propagated as a default to subsequent cells in the same row. For example, a tableau header row can be created without propagating the # format using: Markdown source Output |# Country |# Region |# Minimum Nos. |# Probably Nos. |# Speculative Nos. | | ... | Country Region Minimum Nos. Probably Nos. Speculative Nos. ... You can also use the heading specifier on just the first column, and use an ellipsis to propagate it. Markdown source Output |#\u2026 Country |Region |Minimum Nos. |Probably Nos. |Speculative Nos. | | ... | Country Region Minimum Nos. Probably Nos. Speculative Nos. ... The propagated format is just a default: it can be overridden in any subsequent cell. Markdown source Output |!.vlines | |#... Animal 1 | Animal 1 | Animal 1 | Animal 1 | Animal 1 | |>... ant | bee |<cat | dog | elk | Animal 1 Animal 1 Animal 1 Animal 1 Animal 1 ant bee cat dog elk You can even override it in the cell that initially propagates it: Markdown source Output |#...>... Animal 1 | Animal 1 | Animal 1 | Animal 1 | Animal 1 | |>...< ant | bee |<cat | dog | elk | Animal 1 Animal 1 Animal 1 Animal 1 Animal 1 ant bee cat dog elk Propagating Formats Down a Column Any tableau row that starts |: is a format row. We've already seen a version of this: | Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | |:--------|:-------------|-------------:|--------------:|-----------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | The :--- specifier in the first cell of line two is conventional markdown for \"subsequent cells in this column should be left aligned\". You can specify the same thing using tableau format specifiers: Markdown source Output |#... Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | |:< |< |>... | | | | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Country Region Minimum Nos. Probably Nos. Speculative Nos. India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 By moving the format line above the header, you can align that header, too: Markdown source Output |:< |< |>... | | | |#... Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Country Region Minimum Nos. Probably Nos. Speculative Nos. India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 Here's another example that makes both the first row and first column into headers. Markdown source Output |: #< | > | > | > | > | > | > | > | > | |#\u2026 Bit position | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | | Bits | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | | Place value | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | |^ | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | | Bit x value | 128 | 0 | 0 | 16 | 0 | 0 | 2 | 1 | Bit position 7 6 5 4 3 2 1 0 Bits 1 0 0 1 0 0 1 1 Place value \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 Bit x value 128 0 0 16 0 0 2 1 Table Level Formatting A line starting |! can be used to add CSS classes and/or a caption to the table. |!.hlines.vlines.wide How place values work in binary | |: #< | > | > | > | > | > | > | > | > | |#\u2026 Bit position | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | | Bits | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | | Place value | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | |^ | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | | Bit x value | 128 | 0 | 0 | 16 | 0 | 0 | 2 | 1 | The three classes add horizontal and vertical lines to the table and force it to be a full column wide. Any text after the format becomes the table caption. How place values work in binary Bit position 7 6 5 4 3 2 1 0 Bits 1 0 0 1 0 0 1 1 Place value \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 Bit x value 128 0 0 16 0 0 2 1 Another example of table-level classes is the list of format specifications , which uses the CSS stripe class to get alternating row backgrounds. Nutrition Facts One more example, showing a mockup of a nutrition facts panel. We use a CSS style to make the first and last columns bold (starting at the \"Calories 200\" line). We use three more styles, ull , ulm , and ulb , to draw light, medium, or bold lines under rows, and we use colspans both to indent subcategories and to control where lines are drawn. Finally we use a table formatting line (the last line in the table) to both set a caption and to give the table a CSS class. We use that class both to draw a box around the table and to namespace our other styles. This line also shows the use of a backslash to continue a table row onto the next line. Here's the table markup: |:< |< |> | |.ulb\u2026 Serving Size 1/2 cup (about 82g)<br/>Servings Per Container 8 |{ |{ | |.ull\u2026 Amount Per Serving |{ |{ | |:.bold | |.bold| |.ulm\u2026 Calories 200 |{ | Calories from Fat 130 | |.ull\u2026 | | % Daily Value | | Total Fat |{ | 22% | | |.ull\u2026 Saturated Fat 9g | 22% | |.ull\u2026 | Trans Fat 0g | 0% | |.ull\u2026 Cholesterol 55mg |{ | 18% | |.ull\u2026 Sodium 40mg |{ | 2% | | Total Carbohydrate 17g |{ | 6% | | |.ull\u2026 Dietary Fiber 1g | 4% | |.ull\u2026 | Sugars 14g | 0% | |.ulm\u2026 Protein 3g |{ | |!.nutrition (from \\ [ examples of data tables ]( https://wpdatatables.com/examples-of-data-tables/ )) | The CSS styles are included inline in the Markdown: < style > table . nutrition { border : solid 6 px #666 ; } table . nutrition . bold { font-weight : bold ; } table . nutrition . ull { border-bottom : 1 px solid #222 ; } table . nutrition . ulm { border-bottom : 2 px solid #333 ; } table . nutrition . ulb { border-bottom : 8 px solid #666 ; } </ style > And the result is: (from examples of data tables ) Serving Size 1/2 cup (about 82g) Servings Per Container 8 Amount Per Serving Calories 200 Calories from Fat 130 % Daily Value Total Fat 22% Saturated Fat 9g 22% Trans Fat 0g 0% Cholesterol 55mg 18% Sodium 40mg 2% Total Carbohydrate 17g 6% Dietary Fiber 1g 4% Sugars 14g 0% Protein 3g table.nutrition { border: solid 6px #666; } table.nutrition .bold { font-weight: bold; } table.nutrition .ull { border-bottom: 1px solid #222; } table.nutrition .ulm { border-bottom: 2px solid #333; } table.nutrition .ulb { border-bottom: 8px solid #666; } Formatting and CSS Unlike most markdown table formatters, tableau uses CSS classes and not inline markup to format tables. The stylesheet I used to format this document can be found in docs/assets/css/tableau (and a version using Postcss' preset-env can be found in the project's css directory.)","title":"Tableau: Extended Table Creation"},{"location":"#tableau-extended-table-creation","text":"I write books and courses, and I need to be able to create tables that are just a bit fancier than regular Markdown can generate. How place values work in binary Bit position 7 6 5 4 3 2 1 0 Bits 1 0 0 1 0 0 1 1 Place value \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 Bit x value 128 0 0 16 0 0 2 1 So, I wrote a kind of universal Markdown extension, called Tableau Table . Features include: Headerless tables Multiline headers Multiple separate headers Headers in columns Row and column span Per cell alignment and CSS classes Default attributes, both down columns and across rows Table-wide classes Caption Continuation lines Compatible (with two exceptions) with standard markdown tables And, because I like to experiment with different layouts and formatting, the tables generated by tableau table are styled using CSS classes, not inline attributes.","title":"Tableau: Extended Table Creation"},{"location":"#if-you-want-to-use-tableau-tables","text":"You'll need to find an extension/plugin for the particular Markdown processor you're using. Marked (JavaScript) Extension available on NPM. See https://www.npmjs.com/package/tableau-markd . Markdown-It (JavaScript) Extension available on NPM. See https://www.npmjs.com/package/tableau-markdown-it . Python Markdown The extension is available through GitHub. For information see https://github.com/tableau-tables/python-tableau-parser .","title":"If You Want to Use Tableau Tables"},{"location":"#if-you-use-a-different-markdown-processor","text":"I use multiple Markdown processors, and I didn't want to have to implement a whole new tableau plugin for each. Instead, I wrote two library implementations of tableau, one in Python and the other in JavaScript. These libraries are intended to make it easy to write a plugin so that you can use tableau-formatted tables in a Markdown processor that doesn't currently support it. I wrote the Marked extension in a couple of hours (most of which was spent fighting with Typescript types). If you're interested in writing an extension, see the guide . If your particular environment requires features not currently in the library, let me know and I'll add them. If you'd like to create a version of the libraries for another programming language, please let me know so we can coordinate effort.","title":"If you use a different Markdown Processor"},{"location":"#basic-markup","text":"Tableau is compatible with existing Markdown table conventions providing every row in the markup starts and ends with a pipe character: | Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | |:--------|:-------------|-------------:|--------------:|-----------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Columns are separated using pipe characters (\"|\"), and the second line both separates the headings from the table body and also gives the alignment of each of the columns. Formatted, it looks like this: Country Region Minimum Nos. Probably Nos. Speculative Nos. India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60","title":"Basic Markup"},{"location":"#multiple-header-lines","text":"Output Markdown source Country Region Minimum Probable Speculative Numbers Numbers Numbers India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 | Country | Region | Minimum | Probable | Speculative | | | | Numbers | Numbers | Numbers | |:--------|:-------------|---------:|---------:|-------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Every line before the format line is considered a header.","title":"Multiple Header Lines"},{"location":"#no-header-lines","text":"Output Markdown source India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 |:--------|:-------------|---------:|---------:|-------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 |","title":"No Header Lines"},{"location":"#no-format-line","text":"Output Markdown source India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 |","title":"No Format Line"},{"location":"#spanned-rows","text":"Output Markdown source Country Region Minimum Probable Speculative Numbers Numbers Numbers India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 | Country | Region | Minimum | Probable | Speculative | |^ |^ | Numbers | Numbers | Numbers | |:--------|:-------------|---------:|---------:|-------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | An up-arrow (^) immediately after the pipe in any cell causes it to merge with the cell above. Multiple consecutive cells can be merged.","title":"Spanned Rows"},{"location":"#tableau-format-specifications","text":"In the preceding table, the two cells at the start of the second row are merged with the cells above. This is done using the up-arrow format specification. Every cell in a tableau table can have one or more format specifications. They must immediately follow the cell's opening pipe, with no intervening spaces. The valid format specifications are: ^ Merge this cell with the one above it. Multiple cells in a column may be merged { Merge this cell with the one to its left. Multiple cells in a row may be merged < Left align this cell = Center this cell > Right align this cell # Make this cell a header (use <th> ) .class Apply the CSS class to this cell The two span specifications ( ^ and { ) must appear alone (as the cell formatting is taken from the cell above or to the left). Otherwise, a format specification can contain an optional alignment specifier, an optional heading specifier, and zero or more class specifiers. These three types of specifier can appear in any order: |<#.warn.big Note |.info> Meaning | The first cell is a left-aligned heading cell with the CSS classes warn and big , while the second is a right-aligned cell with the class info .","title":"Tableau Format Specifications"},{"location":"#propagating-formats-along-a-row","text":"Any format specification can be followed by an ellipsis (either three periods ... or a Unicode ellipsis, \u2026 ). This format will then be propagated as a default to subsequent cells in the same row. For example, a tableau header row can be created without propagating the # format using: Markdown source Output |# Country |# Region |# Minimum Nos. |# Probably Nos. |# Speculative Nos. | | ... | Country Region Minimum Nos. Probably Nos. Speculative Nos. ... You can also use the heading specifier on just the first column, and use an ellipsis to propagate it. Markdown source Output |#\u2026 Country |Region |Minimum Nos. |Probably Nos. |Speculative Nos. | | ... | Country Region Minimum Nos. Probably Nos. Speculative Nos. ... The propagated format is just a default: it can be overridden in any subsequent cell. Markdown source Output |!.vlines | |#... Animal 1 | Animal 1 | Animal 1 | Animal 1 | Animal 1 | |>... ant | bee |<cat | dog | elk | Animal 1 Animal 1 Animal 1 Animal 1 Animal 1 ant bee cat dog elk You can even override it in the cell that initially propagates it: Markdown source Output |#...>... Animal 1 | Animal 1 | Animal 1 | Animal 1 | Animal 1 | |>...< ant | bee |<cat | dog | elk | Animal 1 Animal 1 Animal 1 Animal 1 Animal 1 ant bee cat dog elk","title":"Propagating Formats Along a Row"},{"location":"#propagating-formats-down-a-column","text":"Any tableau row that starts |: is a format row. We've already seen a version of this: | Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | |:--------|:-------------|-------------:|--------------:|-----------------:| | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | The :--- specifier in the first cell of line two is conventional markdown for \"subsequent cells in this column should be left aligned\". You can specify the same thing using tableau format specifiers: Markdown source Output |#... Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | |:< |< |>... | | | | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Country Region Minimum Nos. Probably Nos. Speculative Nos. India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 By moving the format line above the header, you can align that header, too: Markdown source Output |:< |< |>... | | | |#... Country | Region | Minimum Nos. | Probably Nos. | Speculative Nos. | | India | Northern | 750 | 875 | 1,000 | | India | Northeastern | 7,200 | 9,250 | 11,300 | | Nepal | | 41 | 50 | 60 | Country Region Minimum Nos. Probably Nos. Speculative Nos. India Northern 750 875 1,000 India Northeastern 7,200 9,250 11,300 Nepal 41 50 60 Here's another example that makes both the first row and first column into headers. Markdown source Output |: #< | > | > | > | > | > | > | > | > | |#\u2026 Bit position | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | | Bits | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | | Place value | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | |^ | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | | Bit x value | 128 | 0 | 0 | 16 | 0 | 0 | 2 | 1 | Bit position 7 6 5 4 3 2 1 0 Bits 1 0 0 1 0 0 1 1 Place value \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 Bit x value 128 0 0 16 0 0 2 1","title":"Propagating Formats Down a Column"},{"location":"#table-level-formatting","text":"A line starting |! can be used to add CSS classes and/or a caption to the table. |!.hlines.vlines.wide How place values work in binary | |: #< | > | > | > | > | > | > | > | > | |#\u2026 Bit position | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | | Bits | 1 | 0 | 0 | 1 | 0 | 0 | 1 | 1 | | Place value | $2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | |^ | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | | Bit x value | 128 | 0 | 0 | 16 | 0 | 0 | 2 | 1 | The three classes add horizontal and vertical lines to the table and force it to be a full column wide. Any text after the format becomes the table caption. How place values work in binary Bit position 7 6 5 4 3 2 1 0 Bits 1 0 0 1 0 0 1 1 Place value \\(2^7\\) \\(2^6\\) \\(2^5\\) \\(2^4\\) \\(2^3\\) \\(2^2\\) \\(2^1\\) \\(2^0\\) 128 64 32 16 8 4 2 1 Bit x value 128 0 0 16 0 0 2 1 Another example of table-level classes is the list of format specifications , which uses the CSS stripe class to get alternating row backgrounds.","title":"Table Level Formatting"},{"location":"#nutrition-facts","text":"One more example, showing a mockup of a nutrition facts panel. We use a CSS style to make the first and last columns bold (starting at the \"Calories 200\" line). We use three more styles, ull , ulm , and ulb , to draw light, medium, or bold lines under rows, and we use colspans both to indent subcategories and to control where lines are drawn. Finally we use a table formatting line (the last line in the table) to both set a caption and to give the table a CSS class. We use that class both to draw a box around the table and to namespace our other styles. This line also shows the use of a backslash to continue a table row onto the next line. Here's the table markup: |:< |< |> | |.ulb\u2026 Serving Size 1/2 cup (about 82g)<br/>Servings Per Container 8 |{ |{ | |.ull\u2026 Amount Per Serving |{ |{ | |:.bold | |.bold| |.ulm\u2026 Calories 200 |{ | Calories from Fat 130 | |.ull\u2026 | | % Daily Value | | Total Fat |{ | 22% | | |.ull\u2026 Saturated Fat 9g | 22% | |.ull\u2026 | Trans Fat 0g | 0% | |.ull\u2026 Cholesterol 55mg |{ | 18% | |.ull\u2026 Sodium 40mg |{ | 2% | | Total Carbohydrate 17g |{ | 6% | | |.ull\u2026 Dietary Fiber 1g | 4% | |.ull\u2026 | Sugars 14g | 0% | |.ulm\u2026 Protein 3g |{ | |!.nutrition (from \\ [ examples of data tables ]( https://wpdatatables.com/examples-of-data-tables/ )) | The CSS styles are included inline in the Markdown: < style > table . nutrition { border : solid 6 px #666 ; } table . nutrition . bold { font-weight : bold ; } table . nutrition . ull { border-bottom : 1 px solid #222 ; } table . nutrition . ulm { border-bottom : 2 px solid #333 ; } table . nutrition . ulb { border-bottom : 8 px solid #666 ; } </ style > And the result is: (from examples of data tables ) Serving Size 1/2 cup (about 82g) Servings Per Container 8 Amount Per Serving Calories 200 Calories from Fat 130 % Daily Value Total Fat 22% Saturated Fat 9g 22% Trans Fat 0g 0% Cholesterol 55mg 18% Sodium 40mg 2% Total Carbohydrate 17g 6% Dietary Fiber 1g 4% Sugars 14g 0% Protein 3g table.nutrition { border: solid 6px #666; } table.nutrition .bold { font-weight: bold; } table.nutrition .ull { border-bottom: 1px solid #222; } table.nutrition .ulm { border-bottom: 2px solid #333; } table.nutrition .ulb { border-bottom: 8px solid #666; }","title":"Nutrition Facts"},{"location":"#formatting-and-css","text":"Unlike most markdown table formatters, tableau uses CSS classes and not inline markup to format tables. The stylesheet I used to format this document can be found in docs/assets/css/tableau (and a version using Postcss' preset-env can be found in the project's css directory.)","title":"Formatting and CSS"},{"location":"samples/","text":"Table from the APA Style Guidelines Result Markdown source Results From a Factor Analysis of the Parental Care and Tenderness (PCAT) Questionnaire PCAT item Loading 1 2 3 Factor 1: Tenderness\u2014Positive 20. You make a baby laugh over and over again by making silly faces. .86 .04 .01 22. A child blows you kisses to say goodbye. .85 \u2212.02 \u2212.01 16. A newborn baby curls its hand around your finger. .84 \u2212.06 .00 19. You watch as a toddler takes their first step and tumbles gently back down. .77 .05 \u2212.07 25. You see a father tossing his giggling baby up into the air as a game. .70 .10 \u2212.03 |!.apa Results From a Factor Analysis of the Parental Care and Tenderness (PCAT) Questionnaire | |#... PCAT item |{ | Loading |{ |{ | |^ |^ |#... 1 | 2 | 3 | |< Factor 1: Tenderness\u2014Positive |{...| |:> |< |>...| | 20.| You make a baby laugh over and over again by making silly faces. | .86 | .04 | .01 | | 22.| A child blows you kisses to say goodbye. | .85 | \u2212.02 | \u2212.01 | | 16.| A newborn baby curls its hand around your finger. | .84 | \u2212.06 | .00 | | 19.| You watch as a toddler takes their first step and tumbles gently back down. | .77 | .05 | \u2212.07 | | 25.| You see a father tossing his giggling baby up into the air as a game. | .70 | .10 | \u2212.03 | Colored Cell Backgrounds .tableau-table.stock td.neg { background: #fdd; } .tableau-table.stock td.pos { background: #dfd; } [data-md-color-scheme=slate] .tableau-table.stock td.neg { background: #633; } [data-md-color-scheme=slate] .tableau-table.stock td.pos { background: #252; } Result Markdown source Fictitious Stock Closing Prices Symbol and Name Volume P/E Close % Change MGC Megacorp 12,312 19 243.75 -1.20 RUR Rostrum's Universal 4,955 21 8.26 0.65 007 Universal Exports 9,582 14 43.85 1.39 SSB South Sea Bubble 32,485 3 0.42 -5.75 |!.stock.hlines Fictitious Stock Closing Prices | |#... Symbol and Name |{ | Volume | P/E | Close | % Change | |:< |< |>... | | MGC | Megacorp | 12,312 | 19 | 243.75 |.neg -1.20 | | RUR | Rostrum's Universal | 4,955 | 21 | 8.26 |.pos 0.65 | | 007 | Universal Exports | 9,582 | 14 | 43.85 |.pos 1.39 | | SSB | South Sea Bubble | 32,485 | 3 | 0.42 |.neg -5.75 | <style> .tableau-table.stock td.neg { background: #fdd ; } .tableau-table.stock td.pos { background: #dfd ; } [data-md-color-scheme=slate] .tableau-table.stock td.neg { background: #633 ; } [data-md-color-scheme=slate] .tableau-table.stock td.pos { background: #252 ; } </style> Nutrition Table table.nutrition { border: solid 6px var(--grid-line-color-normal); } table.nutrition .bold { font-weight: bold; } table.nutrition .ull { border-bottom: 1px solid var(--grid-line-color-normal); } table.nutrition .ulm { border-bottom: 2px solid var(--grid-line-color-normal); } table.nutrition .ulb { border-bottom: 8px solid var(--grid-line-color-normal); } Result Markdown source (from examples of data tables ) Serving Size 1/2 cup (about 82g) Servings Per Container 8 Amount Per Serving Calories 200 Calories from Fat 130 % Daily Value Total Fat 22% Saturated Fat 9g 22% Trans Fat 0g 0% Cholesterol 55mg 18% Sodium 40mg 2% Total Carbohydrate 17g 6% Dietary Fiber 1g 4% Sugars 14g 0% Protein 3g |:< |< |> | |.ulb\u2026 Serving Size 1/2 cup (about 82g)<br/>Servings Per Container 8 |{ |{ | |.ull\u2026 Amount Per Serving |{ |{ | |:.bold | |.bold| |.ulm\u2026 Calories 200 |{ | Calories from Fat 130 | |.ull\u2026 | | % Daily Value | | Total Fat |{ | 22% | | |.ull\u2026 Saturated Fat 9g | 22% | |.ull\u2026 | Trans Fat 0g | 0% | |.ull\u2026 Cholesterol 55mg |{ | 18% | |.ull\u2026 Sodium 40mg |{ | 2% | | Total Carbohydrate 17g |{ | 6% | | |.ull\u2026 Dietary Fiber 1g | 4% | |.ull\u2026 | Sugars 14g | 0% | |.ulm\u2026 Protein 3g |{ | |!.nutrition (from \\ [ examples of data tables ]( https://wpdatatables.com/examples-of-data-tables/ )) | <style> table.nutrition { border: solid 6px var(--grid-line-color-normal); } table.nutrition .bold { font-weight: bold; } table.nutrition .ull { border-bottom: 1px solid var(--grid-line-color-normal); } table.nutrition .ulm { border-bottom: 2px solid var(--grid-line-color-normal); } table.nutrition .ulb { border-bottom: 8px solid var(--grid-line-color-normal); } </style>","title":"Samples"},{"location":"samples/#table-from-the-apa-style-guidelines","text":"Result Markdown source Results From a Factor Analysis of the Parental Care and Tenderness (PCAT) Questionnaire PCAT item Loading 1 2 3 Factor 1: Tenderness\u2014Positive 20. You make a baby laugh over and over again by making silly faces. .86 .04 .01 22. A child blows you kisses to say goodbye. .85 \u2212.02 \u2212.01 16. A newborn baby curls its hand around your finger. .84 \u2212.06 .00 19. You watch as a toddler takes their first step and tumbles gently back down. .77 .05 \u2212.07 25. You see a father tossing his giggling baby up into the air as a game. .70 .10 \u2212.03 |!.apa Results From a Factor Analysis of the Parental Care and Tenderness (PCAT) Questionnaire | |#... PCAT item |{ | Loading |{ |{ | |^ |^ |#... 1 | 2 | 3 | |< Factor 1: Tenderness\u2014Positive |{...| |:> |< |>...| | 20.| You make a baby laugh over and over again by making silly faces. | .86 | .04 | .01 | | 22.| A child blows you kisses to say goodbye. | .85 | \u2212.02 | \u2212.01 | | 16.| A newborn baby curls its hand around your finger. | .84 | \u2212.06 | .00 | | 19.| You watch as a toddler takes their first step and tumbles gently back down. | .77 | .05 | \u2212.07 | | 25.| You see a father tossing his giggling baby up into the air as a game. | .70 | .10 | \u2212.03 |","title":"Table from the APA Style Guidelines"},{"location":"samples/#colored-cell-backgrounds","text":".tableau-table.stock td.neg { background: #fdd; } .tableau-table.stock td.pos { background: #dfd; } [data-md-color-scheme=slate] .tableau-table.stock td.neg { background: #633; } [data-md-color-scheme=slate] .tableau-table.stock td.pos { background: #252; } Result Markdown source Fictitious Stock Closing Prices Symbol and Name Volume P/E Close % Change MGC Megacorp 12,312 19 243.75 -1.20 RUR Rostrum's Universal 4,955 21 8.26 0.65 007 Universal Exports 9,582 14 43.85 1.39 SSB South Sea Bubble 32,485 3 0.42 -5.75 |!.stock.hlines Fictitious Stock Closing Prices | |#... Symbol and Name |{ | Volume | P/E | Close | % Change | |:< |< |>... | | MGC | Megacorp | 12,312 | 19 | 243.75 |.neg -1.20 | | RUR | Rostrum's Universal | 4,955 | 21 | 8.26 |.pos 0.65 | | 007 | Universal Exports | 9,582 | 14 | 43.85 |.pos 1.39 | | SSB | South Sea Bubble | 32,485 | 3 | 0.42 |.neg -5.75 | <style> .tableau-table.stock td.neg { background: #fdd ; } .tableau-table.stock td.pos { background: #dfd ; } [data-md-color-scheme=slate] .tableau-table.stock td.neg { background: #633 ; } [data-md-color-scheme=slate] .tableau-table.stock td.pos { background: #252 ; } </style>","title":"Colored Cell Backgrounds"},{"location":"samples/#nutrition-table","text":"table.nutrition { border: solid 6px var(--grid-line-color-normal); } table.nutrition .bold { font-weight: bold; } table.nutrition .ull { border-bottom: 1px solid var(--grid-line-color-normal); } table.nutrition .ulm { border-bottom: 2px solid var(--grid-line-color-normal); } table.nutrition .ulb { border-bottom: 8px solid var(--grid-line-color-normal); } Result Markdown source (from examples of data tables ) Serving Size 1/2 cup (about 82g) Servings Per Container 8 Amount Per Serving Calories 200 Calories from Fat 130 % Daily Value Total Fat 22% Saturated Fat 9g 22% Trans Fat 0g 0% Cholesterol 55mg 18% Sodium 40mg 2% Total Carbohydrate 17g 6% Dietary Fiber 1g 4% Sugars 14g 0% Protein 3g |:< |< |> | |.ulb\u2026 Serving Size 1/2 cup (about 82g)<br/>Servings Per Container 8 |{ |{ | |.ull\u2026 Amount Per Serving |{ |{ | |:.bold | |.bold| |.ulm\u2026 Calories 200 |{ | Calories from Fat 130 | |.ull\u2026 | | % Daily Value | | Total Fat |{ | 22% | | |.ull\u2026 Saturated Fat 9g | 22% | |.ull\u2026 | Trans Fat 0g | 0% | |.ull\u2026 Cholesterol 55mg |{ | 18% | |.ull\u2026 Sodium 40mg |{ | 2% | | Total Carbohydrate 17g |{ | 6% | | |.ull\u2026 Dietary Fiber 1g | 4% | |.ull\u2026 | Sugars 14g | 0% | |.ulm\u2026 Protein 3g |{ | |!.nutrition (from \\ [ examples of data tables ]( https://wpdatatables.com/examples-of-data-tables/ )) | <style> table.nutrition { border: solid 6px var(--grid-line-color-normal); } table.nutrition .bold { font-weight: bold; } table.nutrition .ull { border-bottom: 1px solid var(--grid-line-color-normal); } table.nutrition .ulm { border-bottom: 2px solid var(--grid-line-color-normal); } table.nutrition .ulb { border-bottom: 8px solid var(--grid-line-color-normal); } </style>","title":"Nutrition Table"},{"location":"write_javascript_plugin/","text":"Using the Tableau Table Library to write a JavaScript Extension Most every Markdown processor has some form of extension of plugin mechanism. Although it is redundant to say it here, be sure to spend a little while reading how your particular processor implements plugins. In general, Markdown processors operate as a pipeline of modules, where each module parses, manipulates, of generates output. Some processors take this further and have separate pipelines for different stages of processing: tokenizing or parsing, handling blocks, handling inline segments, creating indices, and generating HTML, for example. Tableau deals with tables. Tables are a Markdown block element, and so in a pipeline processor you'll be adding code at the block level. The lax syntax of Markdown makes it difficult for processors to be certain what kind of block they are looking at: is it a table, or just a paragraph with a pipe character? They commonly deal with this by having extensions perform a quick sanity check (typically a regular expression match on a block of text). If this passes, the processor can then call the main code of the extension. Even it this point, an extension can discover that the quick test was wrong, and that the block is not one it handles, in which case it uses a specific return value to tell the processor to try an alternative. Processors also differ when in comes to generating HTML. Sometimes the extension generates HTML when it first processes the block, and other times it instead saves information, and the processor will call a separate function to convert that saved information into HTML it can use. The Tableau Table Library The tableau API has three functions: test(src: string): boolean pass this function a string, at it returns true if that string might represent a tableau table, false otherwise. This is the quick-n-nasty regular expression hack. to_ast(str): Ast | false takes a string containing a possible tableau table, validates that it is, and then returns a data structure describing the table contents. This structure is described below. ast_to_html(ast: Ast): string The ast_to_html function takes an AST and generates an HTML representation. The format of this HTML is described below. This function might not be usable if your Markdown processor requires you to use its functions to generate HTML tags. In that case you can always copy the overall structure of the ast_to_html function's code in your code. The Input String The input to both test and to_ast is a single string containing newline-separated lines. Before being processed, the library strips leading and trailing spaces from the string, and then combines any line that ends with a backslash character with the next line. The Ast The Ast represents the whole tab split_out_head le. The Ast has some table-level attributes ( row_count , col_count , caption , and table_classes`), and exports two functions: ast . split_out_head () : { head : Row [], body : Row [] } ast . each_row (( row ) => ...) One of Ast's jobs is to work out which rows are table headers. Use the split_out_head function to return two lists of rows. The head entry contains zero or more rows that constitute the table's header (and will likely wind up inside a <thead> tag). The body entry is the rest of the rows. Sometimes you need to be able to iterate over all rows, header or not (we'll see an example of this when we implement the marked extension below). That's what each_row is for. Rows Rows are simply wrappers for a list of cells. They export a single function: row . each_cell (( cell ) => ... ) Rows have no useful attributes. Cells and Formats A Cell represents a (possibly hidden) rectangular cell in the table. Each cell has six attributes: rowspan_count colspan_count the number of rows, columns, or both this cell should merge with. If the cell is not supposed to merge, the value will be zero. To create a rowspan or colspan attribute value, you'll need to add one to these values. hidden if a cell is being spanned over, then it is marked as hidden, and you shouldn't generate any HTML for it. content a string containing the cell's text content. This string will not have been processed yet, so at some point you'll need to ensure it goes througth a markdown processor. format any object containing the formatting information for this cell (see below) data an attribute that is not used by the tableau library. You can use it to pass information between various phases of the processing pipeline. The Format object s four attributes you may use: alignment a single character string: \"<\", \"=\", or \">\" for left, center, or right. span If this cell is merged with the preceding row or column, this field will contain \"^\" or \"{\". You probably won't use this, as the Ast will have already merged cells and set rowspan_count and colspan_count in the cell being merged from. css_classes A list of css_classes specified for this cell. heading if true , this cell is a heading (rendered using <th> ) Extension Example This section looks at the source for a tableau table plugin for the Marked processor. Before we start, we need to create a new project and install the tableau library and Marked: $ mkdir tableau-marked $ cd tableau-marked $ yarn init -y $ git init $ yarn add -S js-tableau-parser $ yarn add -S marked $ yarn add -D @types/marked $ mkdir src Then do whatever magic you normally do to set up a build environment. Shape of the Extension Marked is a pipeline processor. We need to insert parts of our extension into three parts of that pipeline: The start code, which is used to test whether a block might be suitable for processing with this extension. The tokenizer , where we'll parser our table and, if successful, insert a new token containing our AST into the Marked pipeline. The renderer , where we'll be called to handled the special tableau token we previously injected. These three phases correspond roughly to the test , to_ast , and ast_to_html APIs in the tableau library. Source Code We'll create our extension in src/tableau-marked.ts . src/tableau-marked.ts import * as Tableau from \"js-tableau-parser\" import Marked from \"marked\" type Token = Marked . marked . Token // (1) It took me a while to find the correct type definition, so I aliased it as a reminder to my future, forgetful, self. A Marked extension module exports a descriptor, contain the name and type of extension, and a list of functions to inject into the pipeline. const TABLEAU_EXTENSION = { name : 'tableau' , level : 'block' , start : Tableau.test , //(1) tokenizer , //(2) renderer , //(3) } export default { extensions : [ TABLEAU_EXTENSION ] } The start callback is simply forwarded to the test function in the tableau library. The tokenizer just calls our function of the same name. And the same for the renderer function. The tokenizer needs to verify that the block it is passed contains two or more table rows. That match is performed by the following regular expression. const TABLE_RE = new RegExp ( `(` + `\\\\s{0,3}` + //permitted indentation `\\\\|` + //starting pipe `[^\\\\n]+` + // body of the line (see [1] below) `\\\\|` + // trailing pipe `\\\\s*\\\\n` + // spaces nd EOL `){2,}` ) // Two or more rows is a table Note I like to use the x option so that I can space out and document complex regexps, but JavaScript support is spotty, so instead I just split it into lots of strings and concatenate them. Now let's start the tokenizer function. Marked requires a tokenizer to return a token object. This must have type and raw attributes. To this we add an attribute to hold the ast. interface TableauToken { type : 'tableau' , raw : string , ast : Tableau.Ast } Marked calls the tokenizer with this set to an object containing a lexer. In typescript, you indicate this by adding a typed this parameter to the function definition. Again, here's an alias so I don't have to go grovelling through the index.d.ts file again. type TokenizerThis = Marked . marked . TokenizerThis And now the tokenizer: function tokenizer ( this : TokenizerThis , src : string , _tokens : any ) : TableauToken | undefined { const match = TABLE_RE . exec ( src ); // (1) if ( ! match ) // (2) return const ast = Tableau . to_ast ( match [ 0 ]) // (3) if ( ! ast ) // (4) return // marked makes you tokenize children here, then // render them later ast . each_row ( row => { row . each_cell ( cell => { const tokens : Marked.marked.Token [] = [] this . lexer . inlineTokens ( cell . content , tokens ); // (5) cell . data = tokens }) }) return { type : 'tableau' , raw : match [ 0 ], ast : ast , } } See if the block we receive matches the pattern we defined. If the block doesn't match the pattern, return undefined , which tells Marked to try another tokenizer. If it matches, we call the tableau to_ast function, passing it the matched text. This returns an ast object or false. If the to_ast function failed, then we return undefined and Marked moves on to the next tokenizer. Each cell in the AST contains its original markdown. We need to convert this into HTML by the time we generate output, but, as we've discovered, Marked makes this a two-step process. Here, we call Marked's inline-text tokenizer. The result of parsing the cell's content will be stored in the tokens array, which we then assign to the data attribute of the cell. We'll use it when we render. Now the renderer function. Before using the library's ast_to_html function, it needs to retrieve the tokens representing each cell's content, render it, and stick the resulting HTML back into the cell. type RendererThis = Marked . marked . RendererThis // I _think_ there's a bug in the Marked index.d.ts: the parser passed // to the renderer does not require a renderer as its second parameter type ActualParseInline = ( tokens : Token []) => string function renderer ( this : RendererThis , table : TableauToken ) { table . ast . each_row ( row => { row . each_cell ( cell => { cell . content = ( this . parser . parseInline as ActualParseInline )( cell . data ) }) }) return Tableau . ast_to_html ( table . ast ) } The full source file is here src/tableau-marked.ts import * as Tableau from \"js-tableau-parser\" import Marked from \"marked\" type Token = Marked . marked . Token //////////////////////////////////////////////////////////////////////// const TABLEAU_EXTENSION = { name : 'tableau' , level : 'block' , start : Tableau.test , tokenizer , //: (src: string, tokens: Token[]) => tokenizer(src, tokens), renderer , } //////////////////////////////////////////////////////////////////////// export default { extensions : [ TABLEAU_EXTENSION ] } //////////////////////////////////////////////////////////////////////// // the following defines a row (text between pipe characters) const TABLE_RE = new RegExp ( `(` + `\\\\s{0,3}` + //permitted indentation `\\\\|` + //starting pipe `[^\\\\n]+` + // body of the line (see [1] below) `\\\\|` + // trailing pipe `\\\\s*\\\\n` + // spaces nd EOL `){2,}` ) // Two or more rows is a table // TODO 1: this is a fairly inefficient regexp, as it will backtrack on each // intermediate pipe in a table row. It can be fixed with some negative // lookahead, but I want to keep it simple for now. //////////////////////////////////////////////////////////////////////// interface TableauToken { type : 'tableau' , raw : string , ast : Tableau.Ast } type TokenizerThis = Marked . marked . TokenizerThis function tokenizer ( this : TokenizerThis , src : string , _tokens : any ) : TableauToken | undefined { const match = TABLE_RE . exec ( src ); if ( ! match ) return const ast = Tableau . to_ast ( match [ 0 ]) if ( ! ast ) return // marked make you tokenize children heere, then // render them later ast . each_row ( row => { row . each_cell ( cell => { const tokens : Marked.marked.Token [] = [] this . lexer . inlineTokens ( cell . content , tokens ); cell . data = tokens }) }) return { type : 'tableau' , raw : match [ 0 ], ast : ast , } } //////////////////////////////////////////////////////////////////////// type RendererThis = Marked . marked . RendererThis // I _think_ there's a bug in the Markmed index.d.ts: the parser passed // to the renderer does not require a renderer as its second parameter type ActualParseInline = ( tokens : Token []) => string function renderer ( this : RendererThis , table : TableauToken ) { table . ast . each_row ( row => { row . each_cell ( cell => { cell . content = ( this . parser . parseInline as ActualParseInline )( cell . data ) }) }) return Tableau . ast_to_html ( table . ast ) }","title":"Using the Tableau Table Library to write a JavaScript Extension"},{"location":"write_javascript_plugin/#using-the-tableau-table-library-to-write-a-javascript-extension","text":"Most every Markdown processor has some form of extension of plugin mechanism. Although it is redundant to say it here, be sure to spend a little while reading how your particular processor implements plugins. In general, Markdown processors operate as a pipeline of modules, where each module parses, manipulates, of generates output. Some processors take this further and have separate pipelines for different stages of processing: tokenizing or parsing, handling blocks, handling inline segments, creating indices, and generating HTML, for example. Tableau deals with tables. Tables are a Markdown block element, and so in a pipeline processor you'll be adding code at the block level. The lax syntax of Markdown makes it difficult for processors to be certain what kind of block they are looking at: is it a table, or just a paragraph with a pipe character? They commonly deal with this by having extensions perform a quick sanity check (typically a regular expression match on a block of text). If this passes, the processor can then call the main code of the extension. Even it this point, an extension can discover that the quick test was wrong, and that the block is not one it handles, in which case it uses a specific return value to tell the processor to try an alternative. Processors also differ when in comes to generating HTML. Sometimes the extension generates HTML when it first processes the block, and other times it instead saves information, and the processor will call a separate function to convert that saved information into HTML it can use.","title":"Using the Tableau Table Library to write a JavaScript Extension"},{"location":"write_javascript_plugin/#the-tableau-table-library","text":"The tableau API has three functions: test(src: string): boolean pass this function a string, at it returns true if that string might represent a tableau table, false otherwise. This is the quick-n-nasty regular expression hack. to_ast(str): Ast | false takes a string containing a possible tableau table, validates that it is, and then returns a data structure describing the table contents. This structure is described below. ast_to_html(ast: Ast): string The ast_to_html function takes an AST and generates an HTML representation. The format of this HTML is described below. This function might not be usable if your Markdown processor requires you to use its functions to generate HTML tags. In that case you can always copy the overall structure of the ast_to_html function's code in your code.","title":"The Tableau Table Library"},{"location":"write_javascript_plugin/#the-input-string","text":"The input to both test and to_ast is a single string containing newline-separated lines. Before being processed, the library strips leading and trailing spaces from the string, and then combines any line that ends with a backslash character with the next line.","title":"The Input String"},{"location":"write_javascript_plugin/#the-ast","text":"The Ast represents the whole tab split_out_head le. The Ast has some table-level attributes ( row_count , col_count , caption , and table_classes`), and exports two functions: ast . split_out_head () : { head : Row [], body : Row [] } ast . each_row (( row ) => ...) One of Ast's jobs is to work out which rows are table headers. Use the split_out_head function to return two lists of rows. The head entry contains zero or more rows that constitute the table's header (and will likely wind up inside a <thead> tag). The body entry is the rest of the rows. Sometimes you need to be able to iterate over all rows, header or not (we'll see an example of this when we implement the marked extension below). That's what each_row is for.","title":"The Ast"},{"location":"write_javascript_plugin/#rows","text":"Rows are simply wrappers for a list of cells. They export a single function: row . each_cell (( cell ) => ... ) Rows have no useful attributes.","title":"Rows"},{"location":"write_javascript_plugin/#cells-and-formats","text":"A Cell represents a (possibly hidden) rectangular cell in the table. Each cell has six attributes: rowspan_count colspan_count the number of rows, columns, or both this cell should merge with. If the cell is not supposed to merge, the value will be zero. To create a rowspan or colspan attribute value, you'll need to add one to these values. hidden if a cell is being spanned over, then it is marked as hidden, and you shouldn't generate any HTML for it. content a string containing the cell's text content. This string will not have been processed yet, so at some point you'll need to ensure it goes througth a markdown processor. format any object containing the formatting information for this cell (see below) data an attribute that is not used by the tableau library. You can use it to pass information between various phases of the processing pipeline. The Format object s four attributes you may use: alignment a single character string: \"<\", \"=\", or \">\" for left, center, or right. span If this cell is merged with the preceding row or column, this field will contain \"^\" or \"{\". You probably won't use this, as the Ast will have already merged cells and set rowspan_count and colspan_count in the cell being merged from. css_classes A list of css_classes specified for this cell. heading if true , this cell is a heading (rendered using <th> )","title":"Cells and Formats"},{"location":"write_javascript_plugin/#extension-example","text":"This section looks at the source for a tableau table plugin for the Marked processor. Before we start, we need to create a new project and install the tableau library and Marked: $ mkdir tableau-marked $ cd tableau-marked $ yarn init -y $ git init $ yarn add -S js-tableau-parser $ yarn add -S marked $ yarn add -D @types/marked $ mkdir src Then do whatever magic you normally do to set up a build environment.","title":"Extension Example"},{"location":"write_javascript_plugin/#shape-of-the-extension","text":"Marked is a pipeline processor. We need to insert parts of our extension into three parts of that pipeline: The start code, which is used to test whether a block might be suitable for processing with this extension. The tokenizer , where we'll parser our table and, if successful, insert a new token containing our AST into the Marked pipeline. The renderer , where we'll be called to handled the special tableau token we previously injected. These three phases correspond roughly to the test , to_ast , and ast_to_html APIs in the tableau library.","title":"Shape of the Extension"},{"location":"write_javascript_plugin/#source-code","text":"We'll create our extension in src/tableau-marked.ts . src/tableau-marked.ts import * as Tableau from \"js-tableau-parser\" import Marked from \"marked\" type Token = Marked . marked . Token // (1) It took me a while to find the correct type definition, so I aliased it as a reminder to my future, forgetful, self. A Marked extension module exports a descriptor, contain the name and type of extension, and a list of functions to inject into the pipeline. const TABLEAU_EXTENSION = { name : 'tableau' , level : 'block' , start : Tableau.test , //(1) tokenizer , //(2) renderer , //(3) } export default { extensions : [ TABLEAU_EXTENSION ] } The start callback is simply forwarded to the test function in the tableau library. The tokenizer just calls our function of the same name. And the same for the renderer function. The tokenizer needs to verify that the block it is passed contains two or more table rows. That match is performed by the following regular expression. const TABLE_RE = new RegExp ( `(` + `\\\\s{0,3}` + //permitted indentation `\\\\|` + //starting pipe `[^\\\\n]+` + // body of the line (see [1] below) `\\\\|` + // trailing pipe `\\\\s*\\\\n` + // spaces nd EOL `){2,}` ) // Two or more rows is a table Note I like to use the x option so that I can space out and document complex regexps, but JavaScript support is spotty, so instead I just split it into lots of strings and concatenate them. Now let's start the tokenizer function. Marked requires a tokenizer to return a token object. This must have type and raw attributes. To this we add an attribute to hold the ast. interface TableauToken { type : 'tableau' , raw : string , ast : Tableau.Ast } Marked calls the tokenizer with this set to an object containing a lexer. In typescript, you indicate this by adding a typed this parameter to the function definition. Again, here's an alias so I don't have to go grovelling through the index.d.ts file again. type TokenizerThis = Marked . marked . TokenizerThis And now the tokenizer: function tokenizer ( this : TokenizerThis , src : string , _tokens : any ) : TableauToken | undefined { const match = TABLE_RE . exec ( src ); // (1) if ( ! match ) // (2) return const ast = Tableau . to_ast ( match [ 0 ]) // (3) if ( ! ast ) // (4) return // marked makes you tokenize children here, then // render them later ast . each_row ( row => { row . each_cell ( cell => { const tokens : Marked.marked.Token [] = [] this . lexer . inlineTokens ( cell . content , tokens ); // (5) cell . data = tokens }) }) return { type : 'tableau' , raw : match [ 0 ], ast : ast , } } See if the block we receive matches the pattern we defined. If the block doesn't match the pattern, return undefined , which tells Marked to try another tokenizer. If it matches, we call the tableau to_ast function, passing it the matched text. This returns an ast object or false. If the to_ast function failed, then we return undefined and Marked moves on to the next tokenizer. Each cell in the AST contains its original markdown. We need to convert this into HTML by the time we generate output, but, as we've discovered, Marked makes this a two-step process. Here, we call Marked's inline-text tokenizer. The result of parsing the cell's content will be stored in the tokens array, which we then assign to the data attribute of the cell. We'll use it when we render. Now the renderer function. Before using the library's ast_to_html function, it needs to retrieve the tokens representing each cell's content, render it, and stick the resulting HTML back into the cell. type RendererThis = Marked . marked . RendererThis // I _think_ there's a bug in the Marked index.d.ts: the parser passed // to the renderer does not require a renderer as its second parameter type ActualParseInline = ( tokens : Token []) => string function renderer ( this : RendererThis , table : TableauToken ) { table . ast . each_row ( row => { row . each_cell ( cell => { cell . content = ( this . parser . parseInline as ActualParseInline )( cell . data ) }) }) return Tableau . ast_to_html ( table . ast ) } The full source file is here src/tableau-marked.ts import * as Tableau from \"js-tableau-parser\" import Marked from \"marked\" type Token = Marked . marked . Token //////////////////////////////////////////////////////////////////////// const TABLEAU_EXTENSION = { name : 'tableau' , level : 'block' , start : Tableau.test , tokenizer , //: (src: string, tokens: Token[]) => tokenizer(src, tokens), renderer , } //////////////////////////////////////////////////////////////////////// export default { extensions : [ TABLEAU_EXTENSION ] } //////////////////////////////////////////////////////////////////////// // the following defines a row (text between pipe characters) const TABLE_RE = new RegExp ( `(` + `\\\\s{0,3}` + //permitted indentation `\\\\|` + //starting pipe `[^\\\\n]+` + // body of the line (see [1] below) `\\\\|` + // trailing pipe `\\\\s*\\\\n` + // spaces nd EOL `){2,}` ) // Two or more rows is a table // TODO 1: this is a fairly inefficient regexp, as it will backtrack on each // intermediate pipe in a table row. It can be fixed with some negative // lookahead, but I want to keep it simple for now. //////////////////////////////////////////////////////////////////////// interface TableauToken { type : 'tableau' , raw : string , ast : Tableau.Ast } type TokenizerThis = Marked . marked . TokenizerThis function tokenizer ( this : TokenizerThis , src : string , _tokens : any ) : TableauToken | undefined { const match = TABLE_RE . exec ( src ); if ( ! match ) return const ast = Tableau . to_ast ( match [ 0 ]) if ( ! ast ) return // marked make you tokenize children heere, then // render them later ast . each_row ( row => { row . each_cell ( cell => { const tokens : Marked.marked.Token [] = [] this . lexer . inlineTokens ( cell . content , tokens ); cell . data = tokens }) }) return { type : 'tableau' , raw : match [ 0 ], ast : ast , } } //////////////////////////////////////////////////////////////////////// type RendererThis = Marked . marked . RendererThis // I _think_ there's a bug in the Markmed index.d.ts: the parser passed // to the renderer does not require a renderer as its second parameter type ActualParseInline = ( tokens : Token []) => string function renderer ( this : RendererThis , table : TableauToken ) { table . ast . each_row ( row => { row . each_cell ( cell => { cell . content = ( this . parser . parseInline as ActualParseInline )( cell . data ) }) }) return Tableau . ast_to_html ( table . ast ) }","title":"Source Code"}]}